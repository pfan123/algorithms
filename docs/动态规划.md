# 动态规划


动态规划，这是一种解决棘手问题的方法，它将问题分成小问题，并先着手解决这些小问题。

> 动态规划可帮助你在给定约束条件下找到最优解。

在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。


## 二、解决方案

要设计出动态规划解决方案可能很难，提供一些通用的几点方法：

- 每种动态规划解决方案都涉及网格。
- 单元格中的值通常就是你要优化的值。在前面的背包问题中，单元格的值为商品的价值。
- 每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴。

## 三、最长公共子序列之解决方案

我们来看看网格法求 `FORT` 和 `FOSH`，首先绘制如下网格：

[![img](https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/grid.png)](https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/grid.png)





具体的思路如下：

[![img](https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/function.png)](https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/function.png)





按照上面的分析，核心代码片段可能如下：

```
if word_a[i] == word_b[j]:      ←--------两个字母相同
  cell[i][j] = cell[i-1][j-1] + 1
else:     ←------------------------------两个字母不同
  cell[i][j] = max(cell[i-1][j], cell[i][j-1])
```



## 四、最长公共子串

[![img](https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/grid2.png)](https://raw.githubusercontent.com/chenfengyanyu/my-web-accumulation/master/images/algorithm/grid2.png)



如上图，核心代码片段可能如下：

```
if word_a[i] == word_b[j]:  ←---------两个字母相同
     cell[i][j] = cell[i-1][j-1] + 1
else:  ←------------------------------两个字母不同
  cell[i][j] = 0
```



## 五、实际应用

- 生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相 似。最长公共序列还被用来寻找多发性硬化症治疗方案。
- 你使用过诸如git diff等命令吗?它们指出两个文件的差异，也是使用动态规划实现的。
- 字符串的相似程度。编辑距离(levenshtein distance)指出了两个字符串的相 似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。
- 使用过诸如Microsoft Word等具有断字功能的应用程序吗?它们如何确定在什么地方断字以确保行长一致呢? 使用动态规划!

编写一个函数来查找字符串数组中的最长公共前缀。

```
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    if(strs.length === 0) return '';
    let result = '';
    let len = Math.min.apply(Math, strs.map(item => item.length));
    for(let i = 0; i < len; i++) {
        let tmp = strs.map(item => item.substring(0, i+1));
        if (new Set(tmp).size === 1) result = tmp[0];
    }
    return result;
};
// 输入: ["flower","flow","flight"]
// 输出: "fl"
```

## 小结

- 需要在给定约束条件下优化某种指标时，动态规划很有用。 
- 问题可分解为离散子问题时，可使用动态规划来解决。
- 每种动态规划解决方案都涉及网格。
- 单元格中的值通常就是你要优化的值。
- 每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。
- 没有放之四海皆准的计算动态规划解决方案的公式。


## Other Resouce:

[狄克斯特拉算法与贪婪算法](http://jartto.wang/2018/11/29/algorithm6/)
