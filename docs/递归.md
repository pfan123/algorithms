# 递归和快速排序

递归 `(factorial)` 是很多算法都使用的一种编程方法。

## 理解递归

假设你在祖母的阁楼中翻箱倒柜，发现了一个上锁的神秘手提箱。

![box1](http://img.pfan123.com/box1.png)

祖母告诉你，钥匙很可能在下面这个盒子里。

![box2](http://img.pfan123.com/box2.png)

这个盒子里有盒子，而盒子里的盒子又有盒子。钥匙就在某个盒子中。为找到钥匙，你将使用什么算法?

在你看来，哪种方法更容易呢? 第一种方法使用的是while循环: 只要盒子堆不空，就从中取一个盒子，并在其中仔细查找。

```py
  def look_for_key(main_box):
    pile = main_box.make_a_pile_to_look_through()
    while pile is not empty:
      box = piple.grab_a_box()
      for item in box:
        if item.is_a_box():
          pile.append(item)
        elif item.is_akey():
          print "found the key!"
```
第二种方法使用递归——函数调用自己，这种方法的伪代码如下.
```py
  def look_for_key(box):
    for item in box:
      if item.is_a_box():
        look_for_key(item)
      elif item.is_a_key():
        print "found the key!"
```
这两种方法的作用相同，但第二种方法更清晰。递归只是让解决方案更清晰，并没有性能上的优势。实际上，在有些情况下，使用循环的性能更好。在 Stack Overflow 上说的一句话: “如果使用循环，程序的性能可能更高;如果使用递归，程序可能
 更容易理解。如何选择要看什么对你来说更重要。”

## 基线条件和递归条件

由于递归函数调用自己，因此编写这样的函数时很容易出错，进而导致无限循环。

编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分: 基线条件 `(base case)` 和递归条件 `(recursive case)`。递归条件指的是函数调用自己，而基线条件则 指的是函数不再调用自己，从而避免形成无限循环。

```py
def countdown(i): 
  print i
  if i <= 0: #基线条件 
    return
  else: #递归条件 
    countdown(i-1)
```

## 栈

假设你去野外烧烤，并为此创建了一个待办事项清单——一叠便条。你可将待办事项添加到该清单的任何地方，还可删除任何一个待办事项。一叠便条要简单得多: 插入的待办事项放在清单的最前面; 读取待办事项时，你只读取最上面的那个，并将其删除。因此这个待办事项清单只有两种操作: `压入(插入)`和`弹出(删除并读取)`。

![stack](http://img.pfan123.com/stack.png)

这种数据结构称为栈, 栈是一种简单的数据结构。

> 栈 (stack) 先进后出 （LFIO），队列（queue）先进先出（FFIO）

## 调用栈

计算机在内部使用被称为调用栈（call stack）的栈。


## 分而治之

分而治之 `(divide and conquer，D&C)`—— 一种著名的递归式问题解决方法。D&C算法运用快速排序，速度选择排序快得多，实属优雅代码的典范。

D&C的工作原理：
- (1) 找出简单的基线条件;
- (2) 确定如何缩小问题的规模，使其符合基线条件。 

D&C并非可用于解决问题的算法，而是一种解决问题的思路。

## 快速排序

快速排序是一种常用的排序算法，比选择排序快得多。例如，C语言标准库中的函数 qsort 实现的就是快速排序。快速排序也使用了D&C。

- 从数列中挑出一个元素，称为 “基准值”（pivot）;

- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；

- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

··· py
  def quicksort(array):
    if(len(array) < 2):
      return array  # 基线条件:为空或只包含一个元素的数组是“有序”的
    else:
      pivot = array[0] # 递归条件, 基准值
      less = [ i for i in array[1:] if i <= pivot]
      greater = [ i for i in array[1:] if i > pivot]
      return quicksort(less) + [pivot] + quicksort(greater)
  
  print quicksort([10, 5, 2, 3])
···

## 快速排序大O表示法

快速排序的独特之处在于，其速度取决于选择的基准值。在讨论快速排序的运行时间前，我们再来看看最常见的大O运行时间。

![quicksort](http://img.pfan123.com/quicksort.png)

> 上述图表中的时间是基于每秒执行10次操作计算得到的。这些数据并不准确，这里提供它们 只是想让你对这些运行时间的差别有大致认识。实际上，计算机每秒执行的操作远不止10次。

对于每种运行时间，选择排序，其运行时间 为O(n2)，速度非常慢。快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2) 与选择排序一样慢，平均情况下，快速排序的运行时间为O(n log n)。还有一种名为合并排序(merge sort)的排序算法，其运行时间为O(n log n)，比选择排序快得多。

## 小结

- 递归指的是调用自己的函数。
- 每个递归函数都有两个条件: 基线条件 `(base case)` 和递归条件 `(recursive case)`。 
- 栈有两种操作: 压入和弹出。
- 所有函数调用都进入调用栈。
- 调用栈可能很长，这将占用大量的内存。
- D&C将问题逐步分解。使用D&C处理列表时，基线条件很可能是空数组或只包含一个元 素的数组。
- 实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为 O(n log n)。
- 大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。
- 比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n) 的速度比 O(n) 快得多。

## Other Resouces:

[算法图解3 - 递归，快排](http://jartto.wang/2018/11/26/algorithm3/)
