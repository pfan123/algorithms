# 递归

递归 `(factorial)` 是很多算法都使用的一种编程方法。

如果使用循环，程序的性能可能更高;如果使用递归，程序可能
 更容易理解。如何选择要看什么对你来说更重要。

## 理解递归

假设你在祖母的阁楼中翻箱倒柜，发现了一个上锁的神秘手提箱。

![box1](http://img.pfan123.com/box1.png)

祖母告诉你，钥匙很可能在下面这个盒子里。

![box2](http://img.pfan123.com/box2.png)

这个盒子里有盒子，而盒子里的盒子又有盒子。钥匙就在某个盒子中。为找到钥匙，你将使用什么算法?

在你看来，哪种方法更容易呢? 第一种方法使用的是while循环: 只要盒子堆不空，就从中取一个盒子，并在其中仔细查找。

```py
  def look_for_key(main_box):
    pile = main_box.make_a_pile_to_look_through()
    while pile is not empty:
      box = piple.grab_a_box()
      for item in box:
        if item.is_a_box():
          pile.append(item)
        elif item.is_akey():
          print "found the key!"
```
第二种方法使用递归——函数调用自己，这种方法的伪代码如下.
```py
  def look_for_key(box):
    for item in box:
      if item.is_a_box():
        look_for_key(item)
      elif item.is_a_key():
        print "found the key!"
```
这两种方法的作用相同，但第二种方法更清晰。递归只是让解决方案更清晰，并没有性能上的优势。实际上，在有些情况下，使用循环的性能更好。在 Stack Overflow 上说的一句话: “如果使用循环，程序的性能可能更高;如果使用递归，程序可能
 更容易理解。如何选择要看什么对你来说更重要。”

## 基线条件和递归条件

由于递归函数调用自己，因此编写这样的函数时很容易出错，进而导致无限循环。

编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分: 基线条件 `(base case)` 和递归条件 `(recursive case)`。递归条件指的是函数调用自己，而基线条件则 指的是函数不再调用自己，从而避免形成无限循环。

```py
def countdown(i): 
  print i
  if i <= 0: #基线条件 
    return
  else: #递归条件 
    countdown(i-1)
```

## 栈

假设你去野外烧烤，并为此创建了一个待办事项清单——一叠便条。你可将待办事项添加到该清单的任何地方，还可删除任何一个待办事项。一叠便条要简单得多: 插入的待办事项放在清单的最前面; 读取待办事项时，你只读取最上面的那个，并将其删除。因此这个待办事项清单只有两种操作: `压入(插入)`和`弹出(删除并读取)`。

![stack](http://img.pfan123.com/stack.png)

这种数据结构称为栈, 栈是一种简单的数据结构。

> 栈 (stack) 先进后出 （LFIO），队列（queue）先进先出（FFIO）

## 调用栈

计算机在内部使用被称为调用栈（call stack）的栈。

## 小结

- 递归指的是调用自己的函数。
- 每个递归函数都有两个条件: 基线条件 `(base case)` 和递归条件 `(recursive case)`。 
- 栈有两种操作: 压入和弹出。
- 所有函数调用都进入调用栈。
- 调用栈可能很长，这将占用大量的内存。


