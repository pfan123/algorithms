# 递归和快速排序

递归 `(factorial)` 是很多算法都使用的一种编程方法。

## 理解递归

假设你在祖母的阁楼中翻箱倒柜，发现了一个上锁的神秘手提箱。

![box1](http://img.pfan123.com/box1.png)

祖母告诉你，钥匙很可能在下面这个盒子里。

![box2](http://img.pfan123.com/box2.png)

这个盒子里有盒子，而盒子里的盒子又有盒子。钥匙就在某个盒子中。为找到钥匙，你将使用什么算法?

在你看来，哪种方法更容易呢? 第一种方法使用的是while循环: 只要盒子堆不空，就从中取一个盒子，并在其中仔细查找。

```py
  def look_for_key(main_box):
    pile = main_box.make_a_pile_to_look_through()
    while pile is not empty:
      box = piple.grab_a_box()
      for item in box:
        if item.is_a_box():
          pile.append(item)
        elif item.is_akey():
          print "found the key!"
```
第二种方法使用递归——函数调用自己，这种方法的伪代码如下.
```py
  def look_for_key(box):
    for item in box:
      if item.is_a_box():
        look_for_key(item)
      elif item.is_a_key():
        print "found the key!"
```
这两种方法的作用相同，但第二种方法更清晰。递归只是让解决方案更清晰，并没有性能上的优势。实际上，在有些情况下，使用循环的性能更好。在 Stack Overflow 上说的一句话: “如果使用循环，程序的性能可能更高;如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。”

## 基线条件和递归条件

由于递归函数调用自己，因此编写这样的函数时很容易出错，进而导致无限循环。

编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分: 基线条件 `(base case)` 和递归条件 `(recursive case)`。递归条件指的是函数调用自己，而基线条件则 指的是函数不再调用自己，从而避免形成无限循环。

```py
def countdown(i): 
  print i
  if i <= 0: #基线条件 
    return
  else: #递归条件 
    countdown(i-1)
```

## 栈

假设你去野外烧烤，并为此创建了一个待办事项清单——一叠便条。你可将待办事项添加到该清单的任何地方，还可删除任何一个待办事项。一叠便条要简单得多: 插入的待办事项放在清单的最前面; 读取待办事项时，你只读取最上面的那个，并将其删除。因此这个待办事项清单只有两种操作: `压入(插入)`和`弹出(删除并读取)`。

![stack](http://img.pfan123.com/stack.png)

这种数据结构称为栈, 栈是一种简单的数据结构。

> 栈 (stack) 先进后出 （LFIO），队列（queue）先进先出（FFIO）

## 调用栈

计算机在内部使用被称为调用栈（call stack）的栈。


## 分而治之

分而治之 `(divide and conquer，D&C)`—— 一种著名的递归式问题解决方法。D&C算法运用快速排序，速度选择排序快得多，实属优雅代码的典范。

D&C的工作原理：
- (1) 找出简单的基线条件;
- (2) 确定如何缩小问题的规模，使其符合基线条件。 

D&C并非可用于解决问题的算法，而是一种解决问题的思路。

## 快速排序

快速排序是一种常用的排序算法，比选择排序快得多。例如，C语言标准库中的函数 qsort 实现的就是快速排序。快速排序也使用了D&C。

- 从数列中挑出一个元素，称为 “基准值”（pivot）;

- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；

- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

```py
  def quicksort(array):
    if(len(array) < 2):
      return array  # 基线条件:为空或只包含一个元素的数组是“有序”的
    else:
      pivot = array[0] # 递归条件, 基准值
      less = [ i for i in array[1:] if i <= pivot]
      greater = [ i for i in array[1:] if i > pivot]
      return quicksort(less) + [pivot] + quicksort(greater)
  
  print quicksort([10, 5, 2, 3])
```

## 快速排序大O表示法

快速排序的独特之处在于，其速度取决于选择的基准值。在讨论快速排序的运行时间前，我们再来看看最常见的大O运行时间。

![quicksort](http://img.pfan123.com/quicksort.png)

> 上述图表中的时间是基于每秒执行10次操作计算得到的。这些数据并不准确，这里提供它们 只是想让你对这些运行时间的差别有大致认识。实际上，计算机每秒执行的操作远不止10次。

对于每种运行时间，选择排序，其运行时间 为O(n2)，速度非常慢。快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2) 与选择排序一样慢，平均情况下，快速排序的运行时间为O(n log n)。还有一种名为合并排序(merge sort)的排序算法，其运行时间为O(n log n)，比选择排序快得多。

## 快速排序算法的优化

#### 合理选择快排 pivot

快排直接选择分区的第一个或最后一个元素做 pivot 肯定是不合适的。对于已经排好序，或者接近排好序的情况，会进入最差情况，时间复杂度衰退到 O(n2)。

pivot选取的理想情况是：让分区中比 pivot 小的元素数量和比 pivot 大的元素数量差不多。较常用的做法是三数取中（ midian of three ），即从第一项、最后一项、中间一项中取中位数作为 pivot。当然这并不能完全避免最差情况的发生。所以很多时候会采取更小心、更严谨的 pivot 选择方案（对于大数组特别重要）。比如先把大数组平均切分成左中右三个部分，每个部分用三数取中得到一个中位数，再从得到的三个中位数中找出中位数。

在 javascript v8 引擎中看到了另外一种选择 pivot 的方式：认为超过1000项的数组是大数组，每隔200左右（不固定）选出一个元素，从这些元素中找出中位数，再加入首尾两个元素，从这个三个元素中找出中位数作为 pivot。

> 常见的快排基准的选择方式：
> - 固定基准
> - 随机基准
> - 三数取中

#### 处理重复元素的问题

假如一个数组里的元素全部一样大（或者存在大量相同元素），会怎么样？这是一个边界 case，但是会令快速排序进入最差情况，因为不管怎么选 pivot，都会使分区结果一边很大一边很小。那怎么解决这个问题呢？还是修改分区过程，思路跟上面说的双向分区类似，但是会更复杂，我们需要小于 pivot、等于 pivot、大于 pivot 三个分区。

#### 优化小数组效率

为什么要优化小数组？因为对于规模很小的情况，快速排序的优势并不明显（可能没有优势），而递归型的算法还会带来额外的开销。于是对于这类情况可以选择非递归型的算法来替代，那么就有两个问题：多小的数组算小数组？替换的算法是什么？

通常这个阈值设定为16（ v8 中设定的是10），替换的算法一般是选择排序 或 插入排序。

#### 尾递归优化

快排算法和大多数分治排序算法一样，都有两次递归调用。但是快排与归并排序不同，归并的递归则在函数一开始， 快排的递归在函数尾部，这就使得快排代码可以实施尾递归优化。使用尾递归优化后，可以缩减堆栈的深度，由原来的 O(n) 缩减为 O(logn)。

#### 多线程处理快排

分治法的基本思想是将一个规模为n的问题分解为 k 个规模较小的子问题，这些子问题互相独立且与原问题相同。求解这些子问题，然后将各子问题的解合并，从而得到的原问题的解。由此，在处理快排的时候，可以使用多线程提高排序的效率。


## 小结

- 递归指的是调用自己的函数。
- 每个递归函数都有两个条件: 基线条件 `(base case)` 和递归条件 `(recursive case)`。 
- 栈有两种操作: 压入和弹出。
- 所有函数调用都进入调用栈。
- 调用栈可能很长，这将占用大量的内存。
- D&C将问题逐步分解。使用D&C处理列表时，基线条件很可能是空数组或只包含一个元 素的数组。
- 实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为 O(n log n)。
- 大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。
- 比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n) 的速度比 O(n) 快得多。

## Other Resouces:

[算法图解3 - 递归，快排](http://jartto.wang/2018/11/26/algorithm3/)
[快速排序算法的优化思路总结](https://juejin.im/post/5aa94ca6518825558252120c)
[快速排序的4种优化](https://blog.csdn.net/qq_38289815/article/details/82718428)
