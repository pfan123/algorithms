# 数组和链表

## 计算机内存的工作原理

为了更好的理解数组和链表，先来简单介绍一下计算机内存的工作原理。

> 简单来说：计算机像是很多抽屉的集合体，每个抽屉都有地址。如下图： fe0ffeeb是一个内存单元的地址（细抠起来，这个图形有问题：实际上，计算机的内存是一维的，而图形是二维的）。

![内存单元的地址](http://img.pfan123.com/ram.png)

需要将数据存储到内存时，请求计算机提供存储空间，计算机给一个存储地址。需要存储多项数据时，有两种基本方式：数组和链表。

## 数组和链表

### 数组

数组中所有元素占用连续的内存，所以通过数组首元素地址，可以计算每个元素的地址。元素的位置称为**索引**，数组的索引从0开始，几乎所有的编程语言都从0开始对数组元素进行编号。在同一个数组中,所有元素的类型都必须相同(都为int、double等)。

数组具有以下特点：

- 知道每个元素的地址，支持随机访问方式；时间复杂度O(1)
- 插入元素时，可能导致元素的移动，最坏情况下，会移动所有元素；由于数组需要连续的内存，当前内存可能无法满足元素的存储，需要重新分配内存空间和进行元素的拷贝；插时间复杂度O(n)
- 删除元素后,必须将后面的元素都向前移；时间复杂度O(n)

### 链表

链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。链表中的元素可存储在内存的任何地方。只要有足够的内存空间，就能为链表分配内存。

链表具有以下特点：

- 支持顺序访问方式，只能从第一个元素开始逐个地读取元素，若需要跳跃，链表的效率真的很低；时间复杂度O(n) 
- 在链表中添加元素很容易:只需将其放入内存,并将其地址存储到前一个元素中；时间复杂度O(1)
- 删除元素只需修改前一个元素指向的地址即可；时间复杂度O(1)


![时间复杂度](http://img.pfan123.com/On.png)

数组和链表还被用来实现其他数据结构，比如散列表等。


### 反转链表

示例：

```
输入: 1->2->3->4->5
输出: 5->4->3->2->1
```

```
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
const reverseList = (head) => {
  if(!head || !head.next) return head
  const next = head.next
  const reverseHead = reverseList(next)
  next.next = head
  head.next = null
  return reverseHead
};
```




## 适用场景

有两种访问方式：随机访问和顺序访问 。

顺序访问意味着从第一个元素开始逐个地读取元素。链表只能顺序访问：要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。随机访问意味着可直接跳到第十个元素。

我们经常说数组的读取速度更快，这是因为它们支持随机访问。当然，数组和链表还被用来实现其他数据结构，后面我们细说。

> 链表擅长插入和删除，而数组擅长随机访问，数组比链表使用更广泛。

## 选择排序

算法思想：遍历待排序列表，找出最大或最小的元素，并添加到到新列表的第一个位置；然后找第二大或第二小的元素，依次类推，直到待排序列表里没有元素为止，此时新列表的元素已按降序或升序排列。

选择排序是一种灵巧的算法，但其速度不是很快。需要的总时间为 O(n × n)，即O(n2)。

```js

function selectionSort (arr) {
    const len = arr.length
    let minIndex
    let temp

    for(let i = 0; i < len -1 ; i++){
        minIndex = i
        for(let j = i+1; j<len; j++){
            if(arr[j] < arr[minIndex]){
                minIndex = j
            }
        }

        temp = arr[i]
        arr[i] = arr[minIndex]
        arr[minIndex] = temp
    }

    return arr
}

selectionSort([1,2,5,1,4,2,4,6,10,8])

```

## 小结

- 计算机内存犹如一大堆抽屉。
- 需要存储多个元素时，可使用数组或链表。
- 数组的元素都在一起。
- 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
- 数组的读取速度很快。
- 链表的插入和删除速度很快。
- 在同一个数组中，所有元素的类型都必须相同(都为int、double等)。

## Other Resouces:

[线性表 顺序表 链表 数组](https://juejin.im/post/5c4ad3a8e51d455249763e67)

[算法图解2 - 数组和链表](http://jartto.wang/2018/11/25/algorithm2/)
