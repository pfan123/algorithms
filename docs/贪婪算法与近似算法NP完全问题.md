# 贪婪算法、近似算法、NP完全问题

贪婪算法很简单：每步都采取最优的做法。用专业术语说，每步都选择局部最优解，最终得到的就是全局最优解。

假设有如下课程表，你希望将尽可能多的课程安排在某间教室上。

![贪婪算法](http://img.pfan123.com/chapter1.png)

你没法让这些课都在这间教室上，因为有些课的上课时间有冲突。

![贪婪算法](http://img.pfan123.com/chapter2.png)

你希望在这间教室上尽可能多的课。如何选出尽可能多且时间不冲突的课程呢? 这个问题好像很难，不是吗?b 实际上，算法可能简单得让你大吃一惊。具体做法如下。

(1) 选出结束最早的课，它就是要在这间教室上的第一堂课。

(2) 接下来，必须选择第一堂课结束后才开始的课。同样，你选择结束最早的课，这将是要 在这间教室上的第二堂课。

重复这样做就能找出答案!

可能很多人都说，这个算法太容易、太显而易见，肯定不对。但这正是贪婪算法的优点—— 简单易行! 贪婪算法很简单: 每步都采取最优的做法。

> 对于这个调度问题，上述简单算法找到的就是最优解! 贪婪算法并非在任何情况下都行之有效(如背包问题)，但它易于实现!

## 集合覆盖问题

假设你办了个广播节目，要让全美50个州的听众都收听得到。为此，你需要决定在哪些广播台播出。在每个广播台播出都需要支付费 用，因此你力图在尽可能少的广播台播出。现有广播台名单如下。

![集合覆盖问题](http://img.pfan123.com/chapter3.png)

每个广播台都覆盖特定的区域，不同广播台的覆盖区域可能重叠。

![集合覆盖问题](http://img.pfan123.com/chapter4.png)

如何找出覆盖全美50个州的最小广播台集合呢?听起来很容易，但其实非常难。具体方法如下: 

(1) 列出每个可能的广播台集合，这被称为幂集(power set)。可能的子集有2n个。

![集合覆盖问题](http://img.pfan123.com/chapter5.png)

(2) 在这些集合中，选出覆盖全美50个州的最小集合。

问题是计算每个可能的广播台子集需要很长时间。由于可能的集合有2n个，因此运行时间为 O(2n)。如果广播台不多，只有5~10个，这是可行的。但如果广播台很多，结果将如何呢?随着广播台的增多，需要的时间将激增。假设你每秒可计算10个子集，所需的时间将如下。

![集合覆盖问题](http://img.pfan123.com/chapter6.png)

没有任何算法可以足够快地解决这个问题!怎么办呢?

## 近似算法

针对集合覆盖问题，贪婪算法可化解危机! 使用下面的贪婪算法可得到非常接近的解。

(1) 选出这样一个广播台，即它覆盖了最多的未覆盖州。即便这个广播台覆盖了一些已覆盖 的州，也没有关系。

(2) 重复第一步，直到覆盖了所有的州。

这是一种**近似算法** `(approximation algorithm)`。在获得精确解需要的时间太长时，可使用近似算法。

判断近似算法优劣的标准如下: 

- 速度有多快;
- 得到的近似解与最优解的接近程度。 

贪婪算法是不错的选择，它们不仅简单，而且通常运行速度很快。在这个例子中，贪婪算法的运行时间为O(n2)，其中n为广播台数量。

![集合覆盖问题](http://img.pfan123.com/chapter7.png)

## NP 完全问题

`NP` 完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。

`NP` 完全问题无处不在！如果能够判断出要解决的问题属于 `NP` 完全问题就好了，这样就不用去寻找完美的解决方案，而是使用近似算法即可。

> 但要判断问题是不是NP完全问题很难，易于解决的问题和 `NP` 完全问题的差别通常很小。

简言之，没办法判断问题是不是 `NP` 完全问题，但还是有一些蛛丝马迹可循的。

- 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。
- 涉及“所有组合”的问题通常是 `NP`完全问题。
- 不能将问题分成小问题，必须考虑各种可能的情况。这可能是 `NP`完全问题。
- 如果问题涉及序列(如旅行商问题中的城市序列)且难以解决，它可能就是 `NP`完全问题。 
- 如果问题涉及集合(如广播台集合)且难以解决，它可能就是 `NP`完全问题。
- 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是 `NP`完全问题。



## 小结

- 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。
- 对于 `NP`完全问题，还没有找到快速解决方案。
- 面临 `NP`完全问题时，最佳的做法是使用近似算法。
- 贪婪算法易于实现、运行速度快，是不错的近似算法。


## Other Resouces:

[狄克斯特拉算法与贪婪算法](http://jartto.wang/2018/11/29/algorithm6/)
